from flask import Blueprint, request, jsonify, current_app, g
from app.models import User
from app.utils.auth import create_jwt, auth_required, decode_jwt, service_auth_required, invalidate_token_cache
from app import get_db
from app.utils.db import settings_collection
import requests
from requests.auth import HTTPBasicAuth
import os
from bson import ObjectId
import hmac

auth_bp = Blueprint('auth', __name__)

BIFROST_URL = os.getenv("BIFROST_URL", "http://bifrost:5000")
BIFROST_CLIENT_ID = os.getenv("BIFROST_CLIENT_ID")
BIFROST_CLIENT_SECRET = os.getenv("BIFROST_CLIENT_SECRET")

# --- WEB AUTHENTICATION (Case 2) ---

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Email and password required"}), 400

    existing = User.find_by_email(email)
    if existing:
        return jsonify({"error": "Email already exists"}), 409

    user = User.create_from_email(email, password)
    token = create_jwt(str(user['_id']), user.get('roles', ['user']))

    return jsonify({
        "message": "Registration successful",
        "token": token,
        "user": {
            "id": str(user['_id']),
            "email": user['email'],
            "onboarding_complete": False
        }
    }), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    user = User.find_by_email(email)
    if user and User.verify_password(user, password):
        token = create_jwt(str(user['_id']), user.get('roles', ['user']))

        # Check onboarding status
        profile = get_db().settings.find_one({"account_id": user['_id']})
        onboarding = profile.get('onboarding_complete', False) if profile else False

        return jsonify({
            "token": token,
            "user": {
                "id": str(user['_id']),
                "email": user['email'],
                "telegram_connected": bool(user.get('telegram_id')),
                "onboarding_complete": onboarding
            }
        }), 200

    return jsonify({"error": "Invalid credentials"}), 401

# --- TELEGRAM -> WEB LOGIN (Case 1) ---

@auth_bp.route('/verify-otp', methods=['POST'])
def verify_otp():
    """
    Validates the 6-digit code generated by the Telegram Bot via Bifrost.
    If valid, logs the user into the Web App.
    """
    data = request.get_json()
    code = data.get('code')

    if not code:
        return jsonify({"error": "Code required"}), 400

    # 1. Verify Code with Bifrost
    try:
        res = requests.post(
            f"{BIFROST_URL}/internal/verify-otp",
            json={"code": code},
            auth=(BIFROST_CLIENT_ID, BIFROST_CLIENT_SECRET),
            timeout=5
        )
        res.raise_for_status()
        bifrost_data = res.json()

        if not bifrost_data.get('valid'):
            return jsonify({"error": "Invalid or expired code"}), 401

        telegram_id = bifrost_data.get('telegram_id')

    except Exception as e:
        current_app.logger.error(f"Bifrost OTP verify failed: {e}")
        return jsonify({"error": "Verification service unavailable"}), 503

    # 2. Find or Create User
    user = User.find_by_telegram_id(telegram_id)
    if not user:
        # If user generated a code, they exist in Telegram, so we should sync.
        user = User.create_from_telegram(telegram_id, "Unknown")

    # 3. Generate Web Token
    token = create_jwt(str(user['_id']), user.get('roles', ['user']))

    profile = get_db().settings.find_one({"account_id": user['_id']})
    onboarding = profile.get('onboarding_complete', False) if profile else False

    return jsonify({
        "message": "Login successful",
        "token": token,
        "user": {
            "id": str(user['_id']),
            "telegram_id": telegram_id,
            "email_connected": bool(user.get('email')),
            "onboarding_complete": onboarding
        }
    }), 200

# --- ACCOUNT LINKING (Proxy to Bifrost) ---

@auth_bp.route('/link-account', methods=['POST'])
@auth_required(min_role="user")
def link_account():
    """
    Proxies the account linking request to Bifrost.
    Bifrost handles the actual merging/linking of Email or Telegram credentials.
    """
    try:
        account_id = g.account_id
    except AttributeError:
        return jsonify({'error': 'Invalid session'}), 401

    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400

    # 1. Prepare Payload for Bifrost
    payload = {
        "account_id": account_id,
        **data
    }

    bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
    target_url = f"{bifrost_url}/internal/link-account"
    client_id = current_app.config.get("BIFROST_CLIENT_ID")
    client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

    # 2. Call Bifrost
    try:
        resp = requests.post(
            target_url,
            json=payload,
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=10
        )

        # 3. Handle Response
        if resp.status_code == 200:
            if 'email' in data:
                try:
                    settings_collection().update_one(
                        {'account_id': ObjectId(account_id)},
                        {'$set': {'email': data['email']}}
                    )
                except Exception as e:
                    current_app.logger.warning(f"Failed to update local email cache: {e}")
            return jsonify(resp.json()), 200

        try:
            return jsonify(resp.json()), resp.status_code
        except:
            return jsonify({"error": "Upstream service error"}), resp.status_code

    except requests.exceptions.RequestException as e:
        current_app.logger.error(f"Bifrost link-account failed: {e}")
        return jsonify({"error": "Link service unavailable"}), 503

@auth_bp.route('/link/initiate-telegram', methods=['POST'])
@auth_required(min_role="user")
def initiate_telegram_link():
    """
    Called by Web Frontend.
    1. Asks Bifrost for a 'link_token' for the current user.
    2. Returns a Telegram Deep Link URL.
    """
    try:
        # 1. Get Token from Bifrost
        bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
        client_id = current_app.config.get("BIFROST_CLIENT_ID")
        client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

        resp = requests.post(
            f"{bifrost_url}/internal/generate-link-token",
            json={"account_id": g.account_id},
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=5
        )
        resp.raise_for_status()
        token = resp.json().get('token')

        # 2. Construct Deep Link
        bot_username = os.getenv("TELEGRAM_BOT_USERNAME", "savvify_bot")
        deep_link = f"https://t.me/{bot_username}?start=link_{token}"

        return jsonify({
            "link_url": deep_link,
            "token": token
        })

    except Exception as e:
        current_app.logger.error(f"Failed to init telegram link: {e}")
        return jsonify({"error": "Service unavailable"}), 503

@auth_bp.route('/link/complete-telegram', methods=['POST'])
def complete_telegram_link():
    """
    Called by Telegram Bot when user sends /start link_<token>.
    """
    data = request.get_json()
    token = data.get('token')
    telegram_id = data.get('telegram_id')

    if not token or not telegram_id:
        return jsonify({"error": "Missing token or telegram_id"}), 400

    # Call Bifrost to Consume Token
    bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
    client_id = current_app.config.get("BIFROST_CLIENT_ID")
    client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

    try:
        resp = requests.post(
            f"{bifrost_url}/internal/link-account",
            json={"link_token": token, "telegram_id": telegram_id},
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=5
        )
        if resp.status_code == 200:
            return jsonify({"success": True}), 200
        else:
            return jsonify(resp.json()), resp.status_code
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# --- CACHE INVALIDATION WEBHOOK ---

@auth_bp.route('/internal/webhook/auth-event', methods=['POST'])
def auth_event_webhook():
    """
    Receives and processes Auth Events from Bifrost (IdP).
    Secured via HMAC-SHA256 Signature verification.
    """
    # ---------------------------------------------------------
    # 1. SECURITY: Verify HMAC Signature
    # ---------------------------------------------------------
    signature = request.headers.get('X-Bifrost-Signature')
    client_id = request.headers.get('X-Bifrost-Client-Id')

    if not signature:
        current_app.logger.warning("‚ö†Ô∏è Webhook missing signature header")
        return jsonify({"error": "Missing signature"}), 401

    # Load Shared Secret (Must match Bifrost's DB record for this app)
    webhook_secret = current_app.config.get("BIFROST_WEBHOOK_SECRET")

    if not webhook_secret:
        current_app.logger.critical("‚ùå Configuration Error: Missing BIFROST_WEBHOOK_SECRET")
        return jsonify({"error": "Server configuration error"}), 500

    # Verify Signature (using raw bytes)
    payload_bytes = request.get_data()
    try:
        expected_signature = hmac.new(
            key=webhook_secret.encode('utf-8'),
            msg=payload_bytes,
            digestmod=hashlib.sha256
        ).hexdigest()
    except Exception as e:
        current_app.logger.error(f"HMAC calculation failed: {e}")
        return jsonify({"error": "Internal verification error"}), 500

    if not hmac.compare_digest(expected_signature, signature):
        current_app.logger.warning(f"‚õî Invalid Signature from Claimed Client: {client_id}")
        return jsonify({"error": "Invalid signature"}), 403

    # ---------------------------------------------------------
    # 2. LOGIC: Process Event Types
    # ---------------------------------------------------------
    try:
        data = request.get_json()
        event_type = data.get('event')
        account_id = data.get('account_id')
        token = data.get('token') # Optional: specific token to kill

        current_app.logger.info(f"üîî Webhook Received: [{event_type}] for Account {account_id}")

        # --- A. Critical Security Events (Bans, Logouts) ---
        if event_type == 'invalidation':
            if token:
                if invalidate_token_cache(token):
                    current_app.logger.info(f"   üõ°Ô∏è Token {token[:10]}... added to blocklist.")
                else:
                    current_app.logger.info("   ‚ö†Ô∏è Token not found in cache (might be already expired).")
            else:
                current_app.logger.warning("   ‚ùì Invalidation event received without token.")

        # --- B. Password Changes (Force Logout) ---
        elif event_type == 'security_password_change':
            current_app.logger.info(f"   üîê User {account_id} changed password. Flushing sessions.")
            # If the user is active, their next request will fail validation
            # and force them to re-login with new credentials.
            if token:
                invalidate_token_cache(token)

        # --- C. Role Changes (Premium Upgrades) ---
        elif event_type == 'account_role_change':
            current_app.logger.info(f"   üíé User {account_id} role updated. Refreshing permissions.")
            # We invalidate the cache so the NEXT request from this user
            # triggers a fresh validation call to Bifrost.
            # Bifrost will respond with the NEW role (e.g. "premium_user"),
            # unlocking features immediately.
            if token:
                invalidate_token_cache(token)
            else:
                current_app.logger.info("   ‚ÑπÔ∏è Role changed offline. User gets new role on next login.")

        # --- D. Profile Updates (Email/Name) ---
        elif event_type == 'account_update':
            current_app.logger.info(f"   üìù User {account_id} updated profile. Syncing data...")
            # Similar to role change, we clear cache to force a re-fetch of
            # display_name/email from Bifrost on the next request.
            if token:
                invalidate_token_cache(token)

        else:
            current_app.logger.warning(f"   ‚ùì Unknown event type: {event_type}")

        return jsonify({"status": "processed", "event": event_type}), 200

    except Exception as e:
        current_app.logger.error(f"‚ùå Webhook Processing Error: {e}")
        return jsonify({"error": "Processing failed"}), 400