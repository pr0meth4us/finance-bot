from flask import Blueprint, request, jsonify, current_app, g
from app.models import User
from app.utils.auth import create_jwt, auth_required, decode_jwt
from app import get_db
from app.utils.db import settings_collection
import requests
from requests.auth import HTTPBasicAuth
import os
from bson import ObjectId

auth_bp = Blueprint('auth', __name__)

BIFROST_URL = os.getenv("BIFROST_URL", "http://bifrost:5000")
BIFROST_CLIENT_ID = os.getenv("BIFROST_CLIENT_ID")
BIFROST_CLIENT_SECRET = os.getenv("BIFROST_CLIENT_SECRET")

# --- WEB AUTHENTICATION (Case 2) ---

@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Email and password required"}), 400

    existing = User.find_by_email(email)
    if existing:
        return jsonify({"error": "Email already exists"}), 409

    user = User.create_from_email(email, password)
    token = create_jwt(str(user['_id']), user.get('roles', ['user']))

    return jsonify({
        "message": "Registration successful",
        "token": token,
        "user": {
            "id": str(user['_id']),
            "email": user['email'],
            "onboarding_complete": False
        }
    }), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    user = User.find_by_email(email)
    if user and User.verify_password(user, password):
        token = create_jwt(str(user['_id']), user.get('roles', ['user']))

        # Check onboarding status
        profile = get_db().settings.find_one({"account_id": user['_id']})
        onboarding = profile.get('onboarding_complete', False) if profile else False

        return jsonify({
            "token": token,
            "user": {
                "id": str(user['_id']),
                "email": user['email'],
                "telegram_connected": bool(user.get('telegram_id')),
                "onboarding_complete": onboarding
            }
        }), 200

# --- TELEGRAM -> WEB LOGIN (Case 1) ---

@auth_bp.route('/verify-otp', methods=['POST'])
def verify_otp():
    """
    Validates the 6-digit code generated by the Telegram Bot via Bifrost.
    If valid, logs the user into the Web App.
    """
    data = request.get_json()
    code = data.get('code')

    if not code:
        return jsonify({"error": "Code required"}), 400

    # 1. Verify Code with Bifrost
    try:
        res = requests.post(
            f"{BIFROST_URL}/internal/verify-otp",
            json={"code": code},
            auth=(BIFROST_CLIENT_ID, BIFROST_CLIENT_SECRET),
            timeout=5
        )
        res.raise_for_status()
        bifrost_data = res.json()

        if not bifrost_data.get('valid'):
            return jsonify({"error": "Invalid or expired code"}), 401

        telegram_id = bifrost_data.get('telegram_id')

    except Exception as e:
        current_app.logger.error(f"Bifrost OTP verify failed: {e}")
        return jsonify({"error": "Verification service unavailable"}), 503

    # 2. Find or Create User
    user = User.find_by_telegram_id(telegram_id)
    if not user:
        # If user generated a code, they exist in Telegram, so we should sync.
        user = User.create_from_telegram(telegram_id, "Unknown")

    # 3. Generate Web Token
    token = create_jwt(str(user['_id']), user.get('roles', ['user']))

    profile = get_db().settings.find_one({"account_id": user['_id']})
    onboarding = profile.get('onboarding_complete', False) if profile else False

    return jsonify({
        "message": "Login successful",
        "token": token,
        "user": {
            "id": str(user['_id']),
            "telegram_id": telegram_id,
            "email_connected": bool(user.get('email')),
            "onboarding_complete": onboarding
        }
    }), 200

# --- ACCOUNT LINKING (Proxy to Bifrost) ---

@auth_bp.route('/link-account', methods=['POST'])
@auth_required(min_role="user")
def link_account():
    """
    Proxies the account linking request to Bifrost.
    Bifrost handles the actual merging/linking of Email or Telegram credentials.
    """
    try:
        account_id = g.account_id
    except AttributeError:
        return jsonify({'error': 'Invalid session'}), 401

    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400

    # 1. Prepare Payload for Bifrost
    payload = {
        "account_id": account_id,
        **data
    }

    bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
    target_url = f"{bifrost_url}/internal/link-account"

    client_id = current_app.config.get("BIFROST_CLIENT_ID")
    client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

    # 2. Call Bifrost
    try:
        resp = requests.post(
            target_url,
            json=payload,
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=10
        )

        # 3. Handle Response
        if resp.status_code == 200:
            if 'email' in data:
                try:
                    settings_collection().update_one(
                        {'account_id': ObjectId(account_id)},
                        {'$set': {'email': data['email']}}
                    )
                except Exception as e:
                    current_app.logger.warning(f"Failed to update local email cache: {e}")

            return jsonify(resp.json()), 200

        try:
            return jsonify(resp.json()), resp.status_code
        except:
            return jsonify({"error": "Upstream service error"}), resp.status_code

    except requests.exceptions.RequestException as e:
        current_app.logger.error(f"Bifrost link-account failed: {e}")
        return jsonify({"error": "Link service unavailable"}), 503


@auth_bp.route('/link/initiate-telegram', methods=['POST'])
@auth_required(min_role="user")
def initiate_telegram_link():
    """
    Called by Web Frontend.
    1. Asks Bifrost for a 'link_token' for the current user.
    2. Returns a Telegram Deep Link URL.
    """
    try:
        # 1. Get Token from Bifrost
        bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
        client_id = current_app.config.get("BIFROST_CLIENT_ID")
        client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

        resp = requests.post(
            f"{bifrost_url}/internal/generate-link-token",
            json={"account_id": g.account_id},
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=5
        )
        resp.raise_for_status()
        token = resp.json().get('token')

        # 2. Construct Deep Link
        bot_username = os.getenv("TELEGRAM_BOT_USERNAME", "savvify_bot")
        deep_link = f"https://t.me/{bot_username}?start=link_{token}"

        return jsonify({
            "link_url": deep_link,
            "token": token
        })

    except Exception as e:
        current_app.logger.error(f"Failed to init telegram link: {e}")
        return jsonify({"error": "Service unavailable"}), 503


@auth_bp.route('/link/complete-telegram', methods=['POST'])
def complete_telegram_link():
    """
    Called by Telegram Bot when user sends /start link_<token>.
    """
    data = request.get_json()
    token = data.get('token')
    telegram_id = data.get('telegram_id')

    if not token or not telegram_id:
        return jsonify({"error": "Missing data"}), 400

    # 1. Call Bifrost to Consume Token
    bifrost_url = current_app.config.get("BIFROST_URL", "").rstrip('/')
    client_id = current_app.config.get("BIFROST_CLIENT_ID")
    client_secret = current_app.config.get("BIFROST_CLIENT_SECRET")

    try:
        resp = requests.post(
            f"{bifrost_url}/internal/link-account",
            json={"link_token": token, "telegram_id": telegram_id},
            auth=HTTPBasicAuth(client_id, client_secret),
            timeout=5
        )

        if resp.status_code == 200:
            return jsonify({"success": True}), 200
        else:
            return jsonify(resp.json()), resp.status_code

    except Exception as e:
        return jsonify({"error": str(e)}), 500

# --- BOT SYNC ---

@auth_bp.route('/sync-session', methods=['POST'])
def sync_session():
    """
    Validates a Bifrost Token by calling Bifrost's /auth/me endpoint.
    If valid, creates/syncs a local User session.
    """
    auth_header = request.headers.get('Authorization')
    if not auth_header:
        return jsonify({"error": "Missing token"}), 401

    # We expect format "Bearer <token>"
    parts = auth_header.split(" ")
    if len(parts) != 2:
        return jsonify({"error": "Invalid header format"}), 401

    token = parts[1]

    # 1. Introspect Token with Bifrost
    try:
        verify_url = f"{BIFROST_URL}/auth/me"

        # We pass the token EXACTLY as we received it (forwarding the Bearer token)
        resp = requests.get(
            verify_url,
            headers={"Authorization": f"Bearer {token}"},
            timeout=5
        )

        if resp.status_code != 200:
            current_app.logger.warning(f"Bifrost rejected token: {resp.text}")
            return jsonify({"error": "Invalid session token"}), 401

        bifrost_user = resp.json()

    except requests.exceptions.RequestException as e:
        current_app.logger.error(f"Failed to contact Bifrost for auth: {e}")
        return jsonify({"error": "Authentication unavailable"}), 503

    # 2. Extract Data
    tg_id = bifrost_user.get('telegram_id')
    if not tg_id:
        return jsonify({"error": "Bifrost user has no Telegram ID linked"}), 400

    # 3. Sync with Local Database
    user = User.find_by_telegram_id(tg_id)
    if not user:
        # Create a local shadow user if they don't exist
        # Note: We don't have username/firstname here unless we add it to Bifrost's /me response.
        # For now, we use defaults or partial data.
        user = User.create_from_telegram(tg_id, "User")

    return jsonify({
        "status": "synchronized",
        "user_id": str(user['_id']),
        "is_premium": User.is_premium(user['_id'])
    }), 200